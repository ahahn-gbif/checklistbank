# The GBIF Backbone
Code dealing with using and building the GBIF backbone:
http://www.gbif.org/dataset/d7dddbf4-2cf0-4f39-9b2a-bb099caae36c

# Backbone Matching
The species matching service at GBIF allows to lookup a matching taxon from the GBIF backbone given a scientific name and some optional verbatim classification. 
See [species match service](http://www.gbif.org/developer/species#searching) in our developer docs for usage details.


## Matching confidence
The detailed matching is done against a set of up to 50 potential matching candidates, which are selected based on a native lucene fuzzy query for the scientific name, after going through the [ScientificNameAnalyzer](https://github.com/gbif/checklistbank/blob/master/checklistbank-nub/src/main/java/org/gbif/nub/lookup/ScientificNameAnalyzer.java) which normalizes accents and diacritics. It also does a fair amount of character transpositions also found in [Tony Reese's TaxonMatch algorithm](http://www.cmar.csiro.au/datacentre/taxamatch.htm), see the [ScientificNameSoundAlikeFilter](https://github.com/gbif/checklistbank/blob/master/checklistbank-nub/src/main/java/org/gbif/nub/lookup/ScientificNameSoundAlikeFilter.java).

For each match candidate an overall matching confidence is calculated based on several individual scores which are given in the order of importance:

 - name string similarity
 - classification similarity
 - distance to next best match
 - rank similarity
 - taxonomic status score

### Name similarity
The string similarity of the canonical scientific name is the single most important factor for the overall matching confidence. Only straight canonical name matches are considered trusted matches if no further confidence is found. Fuzzy matches are considered real matches just in cases when the classification provides more evidence.

The backbone matching uses a modified Damerau Levenshtein similarity to measure the string distance of the canonical name which is constructed from the name parts generated by 
parsing the original scientific name with our [NameParser service](http://www.gbif.org/developer/species#parser).

### Classification similarity
The other major impact on the overall confidence comes from comparing the higher classification of the name to be matched with the backbone candidates. For every major rank we determine if the provided higher taxon name matches and aggregate a confidence modifier with not all ranks being treated equal. A difference in the kingdom and family especially is considered a deal breaker.

The comparison of higher ranks is done on a simple case insensitive string equality, but after applying a rather broad synonym lookup based on the information we have in our backbone and manually curated [synonym lookup dictionaries](http://rs.gbif.org/dictionaries/synonyms/).


### Distance to next best match
When the candidate with the highest confidence is found we look at the distance to the next best match and boost the best match confidence in cases when the next best match is far less likely.


### Rank similarity
The rank similarity has little impact, but is responsible for distinguishing between homonyms that exist for higher ranks.

### Status score
Similar to rank the taxonomic status of the backbone record (accepted, synonym or doubtful) has very little impact on the matching result. It is mainly used to prefer the accepted over a synonym over a doubtful taxon.




# Backbone Building
Code that generates a new backbone dataset based on other source checklists.


## Source datasets
 - select the ordered list of nub sources based on the existance & integer value of a checklist registry machine tag "clb:backbonePriority=80"
 - small expert curated patch datasets are possible as source as long as they are registered with GBIF. They should have a very high backbonePriority above 1000 to ensure that their information comes first.
 - there are no means to partially add a dataset or ignore certain groups. Could be considered in a second round of improvements

### Filter source records
 - by default all names of a source dataset are processed
 - ignore strain and cultivar names
 - ignore ranks above family if source dataset is not the Catalog of Life
 - only consider major ranks:
	- kingdom
	- phylum
	- class
	- order
	- family
	- genus
	- species
	- subspecies
	- variety
	- form
- ignore secondary source records if they are conflicting with the taxonomic status of the primary source for the name. i.e. additional information about a name which is accepted in our backbone can only be derived from source datasets which also treat that name as an accepted taxon.


## Overlaying information
 - we merge information about the same name from various sources. Especially updating null values. For example the authorship for a name can be found in a secondary source. Vernacular names and other associated information is also a regular case.

 - every backbone taxon keeps explicitly all core (name, status, author, etc) and associated information (vernacular names, name based typification, descriptions, distribution, bibliography, multimedia)

 - the clb identifier of the primary source taxon (the source clb record with the highest priority) is stored with each backbone taxon to allow to trace back why the backbone has this name

 - use embedded species match to group spelling variations and distinguish homonyms or consider to write a simpler lookup method based on neo4js native lucene indexing

### Multimedia
 - filter by license?

### Distributions
 - ignore invalid area distributions
	 - check location makes sense is not a concatenation???

### Descriptions

### Species profiles
 - check habitats
 

 
## Higher taxa
 - only trust CoL for ranks above family
 - create new families from non CoL sources if we have species for it
 - do not force that all higher ranks must be given, e.g. the order might be missing. Do NOT create placeholder names (incertae sedis) in those cases

## Implicit taxa
 - create missing genera/species for accepted species/subspecies
 - create autonyms (just for plants?)
 - create "incertae sedis" placeholder taxa for missing accepted names for synonyms

## Post build operations
 - verify name string matches expected rank, e.g. no binomial should have a family rank

 - group name recombinations based on the original name. In case many records with the same epithet but different genus exist within the same family, only the latest recombination should be accepted, the other declared synonyms. As this can lead to false groupings require that the authorship exists and suggests it is the same for all recombinations. A group of recombined names can only have a single accepted name. 

 - keep stable nub ids by matching new backbone to current live one

## Implementation details
- use neo4j to assemble the entire backbone before it is written to ChecklistBank
- allows to reuse the existing postgres & solr syncing routines from clb indexing


# Backbone Exports
Code that exports the GBIF backbone checklist as a DwC archive.